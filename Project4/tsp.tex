\documentclass[letterpaper,10pt]{article}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm2e}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{multirow}
\usepackage[margin=1.0in]{geometry}
\usepackage{amsmath,amsthm,amssymb}


\title{Assignment 4: Traveling Salseman Problem}
\author{Francis Vo, Soo-Hyun Yoo}


\setlength{\parindent}{0cm}
\setlength{\parskip}{1em}

\begin{document}

	\subsection{Data Structure}
		The City class holds the input data (id, x, and y) and data about where it is in the Graph like distance from center. The Graph class has vectors of data. Vectors are dynamic arrays that have a constant add time anywhere, simular to a linked list.  But a vector is also better than a linked list because it has a constant pull time.  The Graph class has 3 vectors cities, path, and length.  Cities holds the City in order from input.  Path is the order for the salesman.  Length is in parallel with the path vector and holds the length from the city to the next city. The length vector is not really needed, but it does improve performance time (classical time and memory trade off). 

	\subsection{Algorithm}
		The basics of my algorithm is to add cities that added smallest length to the path.  For this to work, we first needed a path.  This path needed to be a cycle, so the simplest way to get this cycle is grab 3 random points.  But this not good enough, because there is a chance that the 3 points will all be in a corner which will add large paths in the end.  We decided to start with a path around the outside, a convex hull.  Finding this takes O(n^2) time, so we sorted the x and y coordinates.  This would give us the outer laying cities. We can create a big path from this, but its not exactly the convex hull. The next step is very greedy. For every city not on the path, it would check every length between 2 cities that was on the path.  This will find a city to add that will add the least amount of length to the path.  To find this city, it seems like a O(n^2) algorithm, then you have to do it again for the next city to add. To prevent this, we stored the position and how much length it would add to the path. We also had to make sure we checked the added length for the newly added city to the path.  In the end, the algorithm was O(n^2) to add all the cities to the path.  Storing data is very important because it saved us from O(n^3). 

	\subsection{Post Hamiltonian Cycle Path Optimization}
		So after the algorithm finishes, it was about 15\% error from optimal.  Not so great.  I had gnuplot plot my path.  It showed paths that intercepted each other.  So we started looking at where we can flip the routes.  So given cities A,B,C,D in that order on the path. A and B are next to each other, this is the same with C and D.  There is a path between B and C.  We can check if we can optimize this path by comparing the distances AB+CD to AC+BD.  If AC+BD is smaller, than that means we can flip the path BC to creat a smaller path.  This optimization decrease the error to about 5\%.

	\subsection{Recheck Optimzation}
		This was very simple. We removed cities from the path and place them back in using the same algorithm as above, and check if the path is now smaller. If it is, GREAT! Use that path now. 

\end{document}

