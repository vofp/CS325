\documentclass[a4paper,10pt]{article}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm2e}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage[margin=1.0in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
 
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
\lstset{ %
  language=C++,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}

% Title Page
\title{Assignment 1: Introduction to Systems Programming}
\author{Kevin Rich, Francis Vo, Soo-Hyun Yoo}


\begin{document}
	\maketitle

	\section{Mathematical Analysis}
		\subsection{Algorithm 1}
			\begin{algorithm}[H]
				\SetAlgoLined
				\LinesNumbered
				\DontPrintSemicolon
				\KwData{Integer array A of size N}
				\KwResult{Greatest Sum of Subarray}
				\For{$i \gets 0$ \KwTo $N$}{
					\For{$j \gets i$ \KwTo $N$}{
						$s \gets 0$\;
						\For{$k \gets i$ \KwTo $j$}{
							$s \gets s + A[k]$\;
						}
						\If{$s > max$}{
							 $max \gets s$\;
						}
					}
				}
			\caption{Pseudocode for Basic Enumeration}
			\end{algorithm}
			This Algorithm has 3 for-loops so it is O($n^3$).

		\subsection{Algorithm 2}
			\begin{algorithm}[H]
				\SetAlgoLined
				\LinesNumbered
				\DontPrintSemicolon
				\KwData{Integer array A of size N}
				\KwResult{Greatest Sum of Subarray}
				\For{$i \gets 0$ \KwTo $N$}{
					$s \gets 0$\;
					\For{$j \gets i$ \KwTo $N$}{
						 $s \gets A[j]$\;
						 \If{$s > max$}{
							 $max \gets s$\;
						 }
					}
				}
			\caption{Pseudocode for Better Enumeration}
			\end{algorithm}
			This Algorithm has 2 for-loops so it is O($n^2$).

		\subsection{Algorithm 3}
			\noindent {\bf Data}: Integer array A of size N \\
			{\bf Result}: Greatest Sum of Subarray

			\begin{minipage}[!h]{6in}
			\begin{verbatim}

			def MaxSubarray:
			    sums = MaxSubarray_recursive(A)
			    return max(sums)
			\end{verbatim}
			\end{minipage}

			\begin{center}
			\noindent {\bf Algorithm 3.1}: Starting function pseudocode for Divide and Conquer
			\end{center}

			\vspace{1em}
			
			\noindent {\bf Data}: Integer array A of size N \\
			{\bf Result}: Integer array of size 4

			\begin{minipage}[!h]{6in}
			\begin{verbatim}

			def MaxSubarray_recursive:
			    if A.size <= 1:
			        sums.all = A[0]
			        sums.left = A[0]
			        sums.right = A[0]
			        sums.overall = A[0]

			    left_sums = MaxSubarray_recursive(A. left_branch)
			    right_sums = MaxSubarray_recursive(A, right_branch)

			    sums.all = left_sums.all + right_sums.all
			    sums.left = max(left_sums.left, left_sums.all + right_sums.left)
			    sums.right = max(right_sums.right, left_sums.right + right_sums.all)
			    m = left_sums.right + right_sums.left
			    sums.overall = max(sums.all, sums.left, sums.right, m)

			    return sums
			\end{verbatim}
			\end{minipage}

			\begin{center}
			\noindent {\bf Algorithm 3.2}: Recursive function pseudocode for Divide and Conquer
			\end{center}

			\vspace{1em}

			\noindent This algorithm is recursive and decreases by half every step. Each lower step has double the number of calls. Thus, this algorithm is O($n \log n$).


	\section{Theoretical Correctness}

		{\bf Claim}: Given an array of small integers $a[1, \dots, n]$, the divide-and-conquer algorithm (algorithm 3) takes O($n \log n$) time to compute the sum of the maximum subarray, $\displaystyle \max_{i\leq{j}} \sum_{k=i}^j a[k]$.

		{\bf Proof}: Let $n$ be the size of the array of integers, $a$. The recurrence for the recursive step of the algorithm can be found to be

		\begin{align*}
		T(n) &= \Theta(1) + 2T\left(\frac{n}{2}\right) + \Theta(1) \\
			&= 2T\left(\frac{n}{2}\right).
		\end{align*}

		Suppose $T(n) \leq cn \log n$. Substituting, we find:

		\begin{align*}
		T(n) &\leq 2 \cdot c\left(\frac{n}{2}\right) \log \frac{n}{2} \\
			&= cn \log \frac{n}{2} \\
			&\leq cn \log n \\
			&\equiv O(n \log n)
		\end{align*}

		\begin{center}
		$\Box$
		\end{center}


	\section{Testing}

		\begin{tabular}{ | c | c | }
		\hline
		Student ID & Answer\\
		931678074 & 5703 \\
		930569466 & 8184 \\
		932086449 & 4949 \\
		\hline
		\end{tabular}

	\newpage
	\section{Experimental Analysis}

		\subsection{Algorithm 1}
			\begin{figure}[!htb]
				\centering
				\includegraphics[scale=.5]{timingfiles/alg1plot.png}
			\end{figure}
			\begin{figure}[!htb]
				\centering
				\includegraphics[scale=.5]{timingfiles/alg1plotlog.png}
			\end{figure}

		\newpage
		\subsection{Algorithm 2}
			\begin{figure}[!htb]
			\centering
			\includegraphics[scale=.5]{timingfiles/alg2plot.png}
			\end{figure}
			\begin{figure}[!htb]
			\centering
			\includegraphics[scale=.5]{timingfiles/alg2plotlog.png}
			\end{figure}

		\newpage
		\subsection{Algorithm 3}
			\begin{figure}[!htb]
			\centering
			\includegraphics[scale=.5]{timingfiles/alg3plot.png}
			\end{figure}
			\begin{figure}[!htb]
			\centering
			\includegraphics[scale=.5]{timingfiles/alg3plotlog.png}
			\end{figure}

	\newpage
	\section{Extrapolation and Interpretation}

		\subsection{Extrapolation}
			The functions were calculated using gnuplot's fit function.

		\subsection{Interpretation}
			The functions were calculated using gnuplot's fit function and fitting the data to $f(n) = 10^{m * log_{10}(n)+c}$
			The slopes for each algorithm is a little lower than the actual power because of the creation overhead of the function has a larger affect on arrays with small sizes.  This will cause the left side higher and therefore decreases slope.

		\subsection{Algorithm 1}
			\subsubsection{Extrapolation}
				$f(n) = 4.71599 \times 10^{-10} \times n^3$\\
				$f(n) = 3600 \to n = 19690$\\
			\subsubsection{Interpretation}
				Slope $= 2.99734$
		
		\subsection{Algorithm 2}
			\subsubsection{Extrapolation}
				$f(n) = 1.87761 \times 10^{-9} \times n^2$\\
				$f(n) = 3600 \to n = 1384678$
			\subsubsection{Interpretation}
				Slope $= 1.99602$

		\subsection{Algorithm 3}
			\subsubsection{Extrapolation}
				$f(n) = 1.74832 \times 10^{-8} \times n \times log(n)$\\
				$f(n) = 3600 \to n = 8984428998 =8.98 \times 10^9$
			\subsubsection{Interpretation}
				Slope $= 1.00506$

	\newpage
	\section{Code}
		\subsection{Files}
			alg1.cpp - function for algorithm 1\\
			alg2.cpp - function for algorithm 1\\
			alg3.cpp - function for algorithm 1\\
			analysis.cpp - code to run algorithm and measure times for the number of array then outputs .t file\\
			makefile - to compile files\\
			maxSubarray.pdf - \\
			maxSubarray.tex - to create pdf filename\\
			test.cpp - allows input of file, and runs algorithm on input file\\
			analysis/ - hold compiled executables for running analysis\\
			test/ - hold compiled executables for running tests on code, and test array files\\
			timingfiles/ - holds files for creating plots\\
			timingfiles/*.t - files that holds rum times for different array sizes\\
			timingfiles/*.gp - code for gnuplot. 2 plots of each algorithm: 1 normal plot, and 1 log-log plot
		\subsection{Algorithm 1}
		\lstinputlisting[language=C++]{alg1.cpp}
		\newpage
		\subsection{Algorithm 2}
		\lstinputlisting[language=C++]{alg2.cpp}
		\newpage
		\subsection{Algorithm 3}
		\lstinputlisting[language=C++]{alg3.cpp}
		

\end{document}
